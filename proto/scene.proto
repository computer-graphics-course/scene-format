syntax = "proto3";

package scene_format;
option java_package = "com.github.computergraphicscourse.sceneformat";
option java_outer_classname = "SceneFormat";

message Scene {
  int32 version = 1; // "1" is the only allowed value at the moment.
  RenderOptions render_options = 2;
  repeated SceneObject scene_objects = 3;
  repeated Light lights = 4;
  repeated Camera cameras = 5;
  repeated Material materials = 6;
}

// Representation of 3D vectors and points
message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

/*
Representation of RGB colors.
Components should be greater or equal 0. No upper bound
(0, 0, 0) - white
(1, 1, 1) - black
All values greater than 1 should be mapped to range [0, 1] by using gamma correction or just clamping values
*/
message Color {
  double r = 1;
  double g = 2;
  double b = 3;
}

/*
Position, rotation and scale of an object
To calculate transformation matrix:
<ul>
  <li>create translation matrix using position</li>
  <li>create rotation matrix using rotation</li>
  <li>create scale matrix using scale</li>
  <li>and multiple 3 matrices to get final matrix</li>
</ul>
Process using parent is specified below

Right vector can be extracted
from 1st column of the matrix if your renderer uses column-major conversion 
from 1st row of the matrix if your renderer uses row-major conversion 

Up vector can be extracted
from 2nd column of the matrix if your renderer uses column-major conversion 
from 2nd row of the matrix if your renderer uses row-major conversion

Forward vector can be extracted
from 3rd column of the matrix if your renderer uses column-major conversion 
from 3rd row of the matrix if your renderer uses row-major conversion 
*/
message Transform {
  /*
  @default (0, 0, 0)
  */
  Vector3 position = 2;
  /*
  @default (0, 0, 0)
  Rotation in euler angles.
  Can be negative or positive.
  Angles are measured counterclockwise.
  */
  Vector3 rotation = 3;
  /*
  @default (1, 1, 1)
  */
  Vector3 scale = 4;
  /*
  @optional
  @default 0
  Id of parent relative to which transformation should be applied.
  If parent_id is 0 transformation is specified in world space.
  To correctly apply transformation you should build a tree structure representing relationships between objects.
  Then from top to bottom create transformation matrix.
  If object has parent: multiply parent's matrix by object's matrix to get final matrix
  */
  int32 parent_id = 5;
}

/*
Default options for rendering scene.
Can be overridden in renderer
*/
message RenderOptions {
  /*
  @default 1
  Camera from which scene should be rendered
  */
  int32 camera_id = 1;
  /*
  @default 640
  Width of final image
  */
  int32 width = 2;
  /*
  @default 320
  Height of final image
  */
  int32 height = 3;
}

/*
Representation of cube
To determine the position of a cube look at Transform.position
Transform.scale should be ignored
If your renderer supports only axis aligned box Transform.rotation should be ignored
For those who dare to support oriented bounding box here <a href="http://www.opengl-tutorial.org/miscellaneous/clicking-on-objects/picking-with-custom-ray-obb-function/">link</a> how obb is implemented in opengl
*/
message Cube {
  /*
  @default (1, 1, 1)
  Size of cube in each dimension
  */
  Vector3 size = 1;
}

/*
Representation of sphere
Transform.scale should be ignored
To determine the position of a sphere look at Transform.position
*/
message Sphere {
  /*
  @default 1
  Radius of sphere
  */
  double radius = 1;
}

/*
Representation of plane
To determine the position of a plane look at Transform.position
To determine the normal of a plane look at Transform.up
*/
message Plane {}

/*
Representation of disk
To determine the position of a disk look at Transform.position
To determine the normal of a disk look at Transform.up
*/
message Disk {
  /*
  @default 1
  Radius of disk
  */
  double radius = 1;
}

// Mesh specified in obj file 
message MeshedObject {
  /*
  Reference to obj file.
  Absolute or relative path 
  */
  string reference = 2;
}

// Representation of object to render
message SceneObject {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;

  oneof object_material {
    // @oneof 2 material
    // Reference to a material in the array of materials
    string material_id = 3;
    Material material = 4; // @oneof_item
  }

  oneof mesh {
    Sphere sphere = 5; // @oneof 4 mesh
    Cube cube = 6; // @oneof_item
    Plane plane = 7; // @oneof_item
    Disk disk = 8; // @oneof_item
    MeshedObject meshed_object = 9; // @oneof_item
  }
}

/*
Representation of directional light
To determine the direction of a light look at Transform.forward
*/
message LightDirectional {}

/*
Representation of point light
To determine the position of a light look at Transform.position
*/
message LightPoint {}

// This is a sphere of light which surrounds the whole scene.
message LightSurrounding {}

/*
@optional
Representation of sphere light
*/
message LightSphere {
  /*
  @default 1
  Radius of source light
  */
  float radius = 1;
}

// Representation of light
message Light {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 3;
  /*
  @default (1, 1, 1)
  Color of source light
  */
  Color color = 4;
  oneof light {
    LightPoint point = 5; // @oneof 4 light
    LightDirectional directional = 6; // @oneof_item
    LightSphere sphere = 7; // @oneof_item @optional
    LightSurrounding surrounding = 8; // @oneof_item
  }
}

// Representation of perspective camera
message PerspectiveCamera {
  /*
  @default 60
  Horizontal field of view of camera
  */
  double fov = 1;
}

/*
@optional
Representation of orthographic camera
*/
message OrthographicCamera {}

/*
Representation of camera
Camera can be transformed as any other point is space using transformation matrix
and camera viewport is located along negative z-axis
For more detailed explanation you can follow this <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/computing-pixel-coordinates-of-3d-point/mathematics-computing-2d-coordinates-of-3d-points#:~:text=camera%20coordinate%20system%20and%20camera%20space">link</a>
*/
message Camera {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;
  oneof camera {
    PerspectiveCamera perspective = 3; // @oneof 2 camera
    // @oneof_item
    // @optional
    OrthographicCamera orthographic = 4;
  }
}

// Representation of material
message Material {
  string id = 1;
  oneof material {
    SolidMaterial solid = 2; // @oneof 2 material
    MirrorMaterial glass = 3; // @oneof_item
  }
}

// Lambert material
message SolidMaterial {}

// Material for perfect mirror
message MirrorMaterial {}
