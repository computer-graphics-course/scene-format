syntax = "proto3";

package scene_format;
option java_package = "com.github.computergraphicscourse.sceneformat";
option java_outer_classname = "SceneFormat";

message Scene {
  int32 version = 1; // "1" is the only allowed value at the moment.
  RenderOptions render_options = 2;
  repeated SceneObject scene_objects = 3;
  repeated Light lights = 4;
  repeated Camera cameras = 5;
  repeated Material materials = 6;
}

// Representation of 3D vectors and points
message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

/*
Representation of RGB colors.
Components in range [0, 1]
*/
message Color {
  double r = 1;
  double g = 2;
  double b = 3;
}

// Position, rotation and scale of an object
message Transform {
  Vector3 position = 2;
  /*
  Rotation in euler angles.
  Can be negative or positive.
  Angles are measured counterclockwise
  */
  Vector3 rotation = 3;
  Vector3 scale = 4;
  /*
  @optional
  Id of parent relative to which transformation should be applied.
  If parent_id is 0 transformation is specified in world space.
  To correctly apply transformation you should build a tree structure representing relationships between objects.
  Then from top to bottom create transformation matrix.
  If object has parent: multiply parent's matrix by object's matrix to get final matrix
  */
  int32 parent_id = 5;
}

/*
Default options for rendering scene.
Can be overridden in renderer
*/
message RenderOptions {
  // Camera from which scene should be rendered
  int32 camera_id = 1;
  int32 width = 2;
  int32 height = 3;
}

// A Cube contains two fields:
// topLeftForward: Vector3, represents the top left forward point of the cube in space. 
// bottomRightBackward: Vector3, represents the bottom right backward point of the cube in space. 
// Using only this 2 point you can define any cube in space. You need to wrap this type into SceneObject if you need to apply transform, rotate or scale. 
message Cube {
// topLeftForward point
 Vector3 tlf = 1;
 // bottomRightBackward point
 Vector3 brb = 2;
}

// Representation of sphere 
message Sphere {}

// Representation of plane 
message Plane {}

// Mesh specified in obj file 
message MeshedObject {
  /*
  Reference to obj file.
  Absolute or relative path 
  */
  string reference = 2;
}

// Representation of object to render
// A sceneObject is one of the main things of this format. It describes all the required fields to use if you want to render soemthing.
// SceneObject contains:
// - id: defines the id for whole scene.
// - transform: this part has all data for transformation of the object.
// - material: this part contains information about the material, which should be applied to object.
// - mesh: this is the object itself. It may be Plane, Sphere or link to am .obj file, which you are already able to parse.
//
// Using this fields you can render a transformed object of any type with applied material.
message SceneObject {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;

  oneof object_material {
    // @oneof 2 material
    // Reference to material in array of materials
    string material_id = 3;
    // @oneof_item
    Material material = 4;
  }

  oneof mesh {
    // @oneof 4 mesh
    Sphere sphere = 5;
    // @oneof_item
    Cube cube = 6;
    // @oneof_item
    Plane plane = 7;
    // @oneof_item
    MeshedObject meshed_object = 8;
  }
}

// Representation of directional light
message LightDirectional {}

// Representation of point light
message LightPoint {}

// This is a sphere of light which surrounds the whole scene.
message LightSurrounding {}

/*
@optional
Representation of sphere light
*/
message LightSphere {}

// Representation of light
message Light {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 3;
  Color color = 4;
  double intensity = 5;
  oneof light {
    LightPoint point = 6; // @oneof 4 light
    LightDirectional directional = 7; // @oneof_item
    LightSphere sphere = 8; // @oneof_item @optional
    LightSurrounding surrounding = 9; // @oneof_item
  }
}

// Representation of perspective camera
message PerspectiveCamera { double fov = 1; }

/*
@optional
Representation of orthographic camera
*/
message OrthographicCamera {}

message Camera {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;
  oneof camera {
    // @oneof 2 camera
    PerspectiveCamera perspective = 3;
    // @oneof_item
    // @optional
    OrthographicCamera orthographic = 4;
  }
}

// Representation of material
message Material {
  string id = 1;
  oneof material {
    // @oneof 2 material
    SolidMaterial solid = 2;
    // @oneof_item
    MirrorMaterial glass = 3;
  }
}

// Lambert material
message SolidMaterial {}

// Material for perfect mirror
message MirrorMaterial {}
