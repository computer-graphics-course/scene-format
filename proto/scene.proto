syntax = "proto3";

package scene_format;
option java_package = "com.github.computergraphicscourse.sceneformat";
option java_outer_classname = "SceneFormat";

message Scene {
  int32 version = 1; // "1" is the only allowed value at the moment.
  RenderOptions render_options = 2;
  repeated SceneObject scene_objects = 3;
  repeated Light lights = 4;
  repeated Camera cameras = 5;
  repeated Material materials = 6;
}

// Representation of 3D vectors and points
message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

/*
Representation of RGB colors.
Components should be greater or equal 0. No upper bound
*/
message Color {
  double r = 1;
  double g = 2;
  double b = 3;
}

/*
Position, rotation and scale of an object
To calculate transformation matrix
create translation matrix using position
create rotation matrix using rotation
create scale matrix using scale
and multiple 3 matrices to get final matrix
Process using parent is specified below

Right vector can be extract
from 1 column of the transformation matrix if your renderer use column-major conversion 
from 1 row of the transformation matrix if your renderer use row-major conversion 

Up vector can be extract
from 2 column of the transformation matrix if your renderer use column-major conversion 
from 2 row of the transformation matrix if your renderer use row-major conversion

Forward vector can be extract
from 3 column of the transformation matrix if your renderer use column-major conversion 
from 3 row of the transformation matrix if your renderer use row-major conversion 
*/
message Transform {
  /*
  If not specified default value will be (0, 0, 0)
  */
  Vector3 position = 2;
  /*
  Rotation in euler angles.
  Can be negative or positive.
  Angles are measured counterclockwise.
  If not specified default value will be (0, 0, 0)
  */
  Vector3 rotation = 3;
  /*
  If not specified default value will be (1, 1, 1)
  */
  Vector3 scale = 4;
  /*
  @optional
  Id of parent relative to which transformation should be applied.
  If parent_id is 0 transformation is specified in world space.
  To correctly apply transformation you should build a tree structure representing relationships between objects.
  Then from top to bottom create transformation matrix.
  If object has parent: multiply parent's matrix by object's matrix to get final matrix
  */
  int32 parent_id = 5;
}

/*
Default options for rendering scene.
Can be overridden in renderer
*/
message RenderOptions {
  // Camera from which scene should be rendered
  int32 camera_id = 1;
  // Width of final image
  int32 width = 2;
  // Height of final image
  int32 height = 3;
}

/*
Representation of cube
To determine the position of a cube look at Transform.position
Transform.scale should be ignored
If your renderer supports only axis aligned box Transform.rotation should be ignored
For those who dare to support oriented bounding box here link how obb is implemented in opengl:
http://www.opengl-tutorial.org/miscellaneous/clicking-on-objects/picking-with-custom-ray-obb-function/
*/
message Cube {
  // Size of cube in each dimension
  Vector3 size = 1;
}

/*
Representation of sphere
Transform.scale should be ignored
To determine the position of a sphere look at Transform.position
*/
message Sphere {
  // Radius of sphere
  float radius = 1;
}

/*
Representation of plane
To determine the position of a plane look at Transform.position
To determine the normal of a plane look at up vector of transformation
*/
message Plane {}

/*
Representation of disk
To determine the position of a disk look at Transform.position
To determine the normal of a disk look at up vector of transformation
*/
message Disk {
  // Radius of disk
  float radius = 1;
}

// Mesh specified in obj file 
message MeshedObject {
  /*
  Reference to obj file.
  Absolute or relative path 
  */
  string reference = 2;
}

// Representation of object to render
message SceneObject {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;

  oneof object_material {
    // @oneof 2 material
    // Reference to a material in the array of materials
    string material_id = 3;
    Material material = 4; // @oneof_item
  }

  oneof mesh {
    Sphere sphere = 5; // @oneof 4 mesh
    Cube cube = 6; // @oneof_item
    Plane plane = 7; // @oneof_item
    MeshedObject meshed_object = 8; // @oneof_item
  }
}

/*
Representation of directional light
To determine the direction of a light look at forward vector of transformation
*/
message LightDirectional {}

/*
Representation of point light
To determine the position of a light look at Transform.position
*/
message LightPoint {}

// This is a sphere of light which surrounds the whole scene.
message LightSurrounding {}

/*
@optional
Representation of sphere light
*/
message LightSphere {
  // Radius of source light
  float radius = 1;
}

// Representation of light
message Light {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 3;
  // Color of source light
  Color color = 4;
  oneof light {
    LightPoint point = 6; // @oneof 4 light
    LightDirectional directional = 7; // @oneof_item
    LightSphere sphere = 8; // @oneof_item @optional
    LightSurrounding surrounding = 9; // @oneof_item
  }
}

// Representation of perspective camera
message PerspectiveCamera {
  /*
  Horizontal field of view of camera
  */
  double fov = 1;
}

/*
@optional
Representation of orthographic camera
*/
message OrthographicCamera {}

/*
Representation of camera
Look direction of a camera is defined as -Transform.forward
*/
message Camera {
  /*
  Object id in scene.
  Should be equal or greater than 1.
  Should be unique across all Camera, Light and SceneObject
  */
  int32 id = 1;
  Transform transform = 2;
  oneof camera {
    PerspectiveCamera perspective = 3; // @oneof 2 camera
    // @oneof_item
    // @optional
    OrthographicCamera orthographic = 4;
  }
}

// Representation of material
message Material {
  string id = 1;
  oneof material {
    SolidMaterial solid = 2; // @oneof 2 material
    MirrorMaterial glass = 3; // @oneof_item
  }
}

// Lambert material
message SolidMaterial {}

// Material for perfect mirror
message MirrorMaterial {}
